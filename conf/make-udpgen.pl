#! /usr/bin/perl -w
#
# Copyright (c) 2000 Massachusetts Institute of Technology.
#
# make-udpgen.pl -- make an udpgen configuration
#
# ./make-udpgen.pl s d r t
#    options: s - network number of source (e.g. 2)
#             d - network number of destination (e.g. 3)
#             r - rate
#             t - duration
#    generate packets from s.0.0.2 to d.0.0.2 via s.0.0.1, r number
#    of packets per section, for t seconds

my $rtrifs = [ 
# ethernet address of card on router
	[ "00:C0:95:E2:16:9C" ], # 1.0.0.1
	[ "00:C0:95:E2:16:9D" ], # 2.0.0.1
	[ "00:C0:95:E2:09:14" ], # 3.0.0.1
	[ "00:C0:95:E2:09:15" ], # 4.0.0.1
	[ "00:C0:95:E1:FC:D4" ], # 5.0.0.1
	[ "00:C0:95:E1:FC:D5" ], # 6.0.0.1
	[ "00:C0:95:E1:FC:D6" ], # 7.0.0.1
	[ "00:C0:95:E1:FC:D7" ], # 8.0.0.1
];

my $cltifs = [
# ethernet address of sender/receiver, interface on machine for tx/rx
	[ "00:00:C0:8A:67:EF", "eth1" ], # 1.0.0.2
	[ "00:00:C0:B4:68:EF", "eth0" ], # 2.0.0.2
	[ "00:E0:29:05:E4:DA", "eth1" ], # 3.0.0.2
	[ "00:00:C0:61:67:EF", "eth1" ], # 4.0.0.2
	[ "00:00:C0:4F:71:EF", "eth1" ], # 5.0.0.2
	[ "00:00:C0:CA:68:EF", "eth1" ], # 6.0.0.2
	[ "00:E0:29:05:E2:D4", "eth1" ], # 7.0.0.2
	[ "00:A0:CC:55:E3:D0", "eth1" ], # 8.0.0.2
];

if ($#ARGV != 3) {
  print "usage: make-udpgen.pl src dest rate time\n";
  print "   where src and dest are network numbers between 1 and 8\n";
  exit();
}

my $s = $ARGV[0];
my $d = $ARGV[1];
my $r = $ARGV[2];
my $t = $ARGV[3];

if ($s < 1 || $s > 8 || $d < 1 || $d > 8) {
  print "usage: make-udpgen.pl src dest rate time\n";
  print "   where src and dest are network numbers between 1 and 8\n";
  exit();
}

my $limit = int($r * $t);

print "// Generated by make-udpgen.pl\n";

{
print <<EOF

ar	:: ARPResponder($s.0.0.2 $cltifs->[$s-1]->[0]);
udph	:: UDPIPEncap($s.0.0.2, 1234, $d.0.0.2, 1234, 1);
ethh	:: EtherEncap(0x800, $cltifs->[$s-1]->[0], $rtrifs->[$s-1]->[0]);
c0	:: Classifier(12/0806 20/0001, -);
pd	:: PollDevice($cltifs->[$s-1]->[1]);
td	:: ToDevice($cltifs->[$s-1]->[1]);
out	:: Queue(8192) -> Counter -> td;
tol	:: ToHost;

pd -> [0]c0;
c0[0] -> ar -> out;
c0[1] -> tol;

// ether header size 14
// ip header size 20
// udp header size 8
// pkt len is 42+payload length
// so for 64 byte packets, use 22 byte payloads

rs :: RatedSource(\\<00000000111111112222222233333333444444445555>, $r, $limit);
rs -> udph
   -> ethh
   -> Counter
   -> out;

// ticket for RatedSoure must be smaller so it won't overflow the queue
ScheduleInfo(td 1, pd .1, rs .1);
EOF
}

