#!/usr/bin/perl -w

use strict;

if (scalar(@ARGV) < 2) { print STDERR "usage: gen-loss-rate-tables.pl sz1 sz2\n"; exit 1; }

my $sz1 = int(shift);
my $sz2 = int(shift);

if ($sz1 <= 0 || $sz2 <= 0) { die "Bad sizes"; }

my $max_rate = 100;
my $rate_step = 5;
my $num_rates = 1 + $max_rate / $rate_step;

my $max_size = 1600;
my $size_step = 10;
my $num_sizes = 1 + $max_size / $size_step;

print "
// This file automatically generated by
// 'gen-loss-rate-tables.pl $sz1 $sz2'
// Do not edit by hand.

#ifndef LOSS_RATE_TABLE
#define LOSS_RATE_TABLE

static const unsigned table_sz1 = $sz1;
static const unsigned table_sz2 = $sz2;
       
static const unsigned table_max_rate  = $max_rate;
static const unsigned table_num_rates = $num_rates;
static const unsigned table_rate_step = $rate_step;
       
static const unsigned table_max_size  = $max_size;
static const unsigned table_num_sizes = $num_sizes;
static const unsigned table_size_step = $size_step;
 
// keyed by r1, r2, sz
static const unsigned char delivery_rate_table[][$num_rates][$num_sizes] = {
";

sub round($) {
    my $x = shift;
    if (int($x) == $x) { return $x; }
    else { return int($x + 0.5); }
}

# $Pb --  per-byte loss rate probability, keyed by r1:r2
# $Pf -- first-byte loss rate prob.

for (my $r1 = 0; $r1 <= $max_rate; $r1 += $rate_step) {
    print "  { // r1 = $r1 \n";
    for (my $r2 = 0; $r2 <= $max_rate; $r2 += $rate_step) {
	print "    // r2 = $r2\n";
	print "    { ";

	if ($r1 == 0) {
	    for (my $sz = 0; $sz < $max_size; $sz += $size_step) {
		print "0, ";
	    }
	    print "0 },\n";
	    next;
	}

	my $R;
	if ($r2 > 0) {
	    $R = $r1 / $r2;
	}
	else {
	    $R = $r1 * 10000;
	}
	my $Pb = 1 - exp(log($R) / ($sz1 - $sz2));
	
	if ($Pb < 0) { 
	    print STDERR "Limiting Pb to 0, r1=$r1, r2=$r2\n";
	    if ($r1 >= $r2) {
		print STDERR "XXX R >= 1\n";
	    }
	    $Pb = 0;
	}
	
	if ($Pb > 1) { 
	    print STDERR "Limiting Pb to 1, r1=$r1, r2=$r2\n";
	    $Pb = 1;
	}
	
	my $bot = (1 - $Pb)**($sz1 + 76); # +76 for PCP & encap hdr
	if ($bot == 0) {
	    print STDERR "Bad Pb=$Pb, r1=$r1, r2=$r2\n";
	    # next;
	}
	my $Pf = ($bot == 0) ? 0 : (1 - .01*$r1 / $bot);
	
	for (my $sz = 0; $sz <= $max_size; $sz += $size_step) {
	    
	    my $r = (1-$Pf)*((1-$Pb)**($sz+76));
	    if ($r > 1) {
		$r = 1;
		# print STDERR "Limiting r to 1, r1=$r1, r2=$r2, sz=$sz\n";
	    }

	    print round($r*100);
	    if ($sz < $max_size) {
		print ", ";
	    }
	}
	print " }";
	if ($r2 < $max_rate) { print ","; }
	print "\n";
    }
    print " }";
    if ($r1 < $max_rate) { print ","; }
    print "\n";
}


print "};


static inline unsigned char
lookup_delivery_rate(unsigned r1, unsigned r2, unsigned sz) 
{
  assert(sizeof(delivery_rate_table) == sizeof(unsigned char)*table_num_rates*table_num_rates*table_num_sizes);
  if (r1 > table_max_rate || r2 > table_max_rate || sz > table_max_size)
    return 0xff;

  unsigned i1 = r1 / table_rate_step;
  if ((r1 % table_rate_step) > (table_rate_step / 2)) 
    i1++; // round up to closest entry
  assert(i1 < table_num_rates);

  unsigned i2 = r2 / table_rate_step;
  if ((r2 % table_rate_step) > (table_rate_step / 2))
    i2++;
  assert(i2 < table_num_rates);

  unsigned i3 = sz / table_size_step;
  if ((sz % table_size_step) > (table_size_step / 2))
    i3++;
  assert(i3 < table_num_sizes);

  return delivery_rate_table[i1][i2][i3];
}



#endif

";
