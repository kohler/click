/*
 * ip6classifier_parse_stack.{cc,hh} -- Parse stack for IP-packet filter with tcpdumplike syntax
 * Glenn Minne
 *
 * Copyright (c) 2000-2007 Mazu Networks, Inc.
 * Copyright (c) 2010 Meraki, Inc.
 * Copyright (c) 2004-2011 Regents of the University of California
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, subject to the conditions
 * listed in the Click LICENSE file. These conditions include: you must
 * preserve this copyright notice, and you cannot mention the copyright
 * holders in advertising related to the Software without their permission.
 * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
 * notice is a summary of the Click LICENSE file; the license in that file is
 * legally binding.
 */

#include "ip6classifier_parsestack.hh"

CLICK_DECLS

namespace ip6classification {

    /*
     * @brief Creates the negated version of the original node given.
     * An example: an ASTNode containing,
     * "host 10.5.6.2 or host 10.2.3.5" looks as follows
     * 
     *                     or
     *                     |
     *           --------------------
     *           |                  |
     *      host 10.5.6.2    host 10.2.3.5
     *   
     * And will be negated by this function into,
     *  
     *                     and
     *                     |
     *          -------------------------
     *          |                       |
     *      not host 10.5.6.2   not host 10.2.3.5
     *   
     * This is principle for negating the trees is based on the mathematical rules:
     * not (a or b) => not a and not b
     * not (a and b) => not a or not b
     *
     * Or concretely based on this example, "not (host 10.5.6.2 or host 10.2.3.5)" gave
     * "not host 10.5.6.2 and not host 10.2.3.5".
     */
    Token* create_negated_node(ASTNode *original_node) {        // This function works recursively. The old node remains unaltered but the new node being created will contain
                                                                // the previous tree in but than negated.
        // 1. This is the base case, terminating case, or leaf node of the recursive procedure    
        if (dynamic_cast<PrimitiveToken*>(original_node)) {
            PrimitiveToken *negated_primitive = ((PrimitiveToken*) original_node)->clone_and_invert_not_keyword_seen();
            return negated_primitive;
        // 2. Here follow the set of rules that reduce to the base case
        } else if (AndCombinerToken *and_combiner_token = dynamic_cast<AndCombinerToken*>(original_node)) {
            OrCombinerToken *negated_node = new OrCombinerToken();
            negated_node->left_child = create_negated_node(and_combiner_token->left_child);
            negated_node->right_child = create_negated_node(and_combiner_token->right_child);
            return negated_node;
        } else {    // it is an OrCombinerToken*
            OrCombinerToken *or_combiner_token = (OrCombinerToken*) original_node;
            AndCombinerToken *negated_node = new AndCombinerToken();
            negated_node->left_child = create_negated_node(or_combiner_token->left_child);
            negated_node->right_child = create_negated_node(or_combiner_token->right_child);
            return negated_node;
        }
    }

    /*
     * @brief pushes the Token on the parse stack and evaluates the parse stack if needed
     * The parse stack is evaluated whenever a ')' token or the 'end of line' token was found.
     *
     * The ipfiltering::ParseStack ADT (abstract data type) is not just a normal stack used for parsing. It is a concept in its own and is explained below. The idea is that tokens
     * get pushed on this ADT, and then evaluated into a single token which contains multiple tokens in a tree-like structure in it. To gradually change the list of
     * Tokens generated by the Lexer, into a single Token which contains all our Tokens in an AST (Abstract Syntax Tree) structure. This AST can later on run-time be
     * walked through to determine on which output port our packet must be pushed.
     * 
     * How it works:
     * First and for all it is important that in the end our aim is to replace our whole list of unconnected/non-tree format tokens given to us by the Lexer, by only a single token by using
     * evaluation one (in case we have no parentheses) or multiple times. Evaluation means replacing multiple tokens possibly surrounded by one parentheses by one "super token" 
     * who knows (and has in it) all the information of the tokens it evaluated/reduced to this single Token. (for those interested, every ipfilter::Token is in fact a 
     * ipfilter::ASTNode which has a ASTNode *left_child and ASTNode *right_child member in it, hence every Token has the capacity to be a Binary Tree which our AST will be)
     * 
     * This one single token we want in the end will have all the information of our full Token list. But it has it in a tree format.
     *
     * We push the unconnected/non-tree format tokens we got from the Lexer one by one the top of the stack. However, when we see a RightParenthesisToken or EndOfLineToken we are
     * going to replace (in the case of RightParenthesisToken the tokens between the left and right parenthesis, in the case of EndOfLineToken all tokens) the Tokens on the stack
     * by a single Token which contains the information of all the previous tokens in it.
     *
     * Example:
     * We are going to show the functionality of the int push_and_evaluate(Token *token, ErrorHandler *errh) below by an example. We are going to show you have this function step
     * by step builds up the tree, given only a stack, and an evaluate functionality.
     *
     * Let us say we have the following list of Tokens: <IPHostPrimitiveToken AndCombinerToken IP6HostPrimitiveToken EndOfLineToken>, 
     * with which I mean a list of 4 tokens from which the first token is of type IPHostPrimitiveToken, the second is of type AndCombinerToken, the third token is of type
     * IP6HostPrimitiveToken and the last token is of type EndOfLineToken
     *
     * Now we are going to perform exactly 4 calls to the function push_and_evaluate(Token *token, ErrorHandler *errh) and we push 4 times a token of the type corresponding to 
     * the list explained above. We are going to show the 4 calls below, and explain what happens on the stack each time.
     *
     * call 1: push IPHostPrimitiveToken on the top of the stack
     * call 2: push AndCombinerToken on the top of the stack
     * call 3: push IP6HostCombinerToken on the top of the stack
     * call 4: EndOfLineToken found, we need to evaluate everything that is still on the top of the stack.     
     *         =>   We evaluate and we change the 3 previous Tokens into one AndCombinerToken which has as it first child IPHostPrimitiveToken and 
     *              as its second child IP6HostPrimitiveToken. Visually,
     *                                 
     *                                      AndCombinerToken
     *                                              |
     *                                    -------------------
     *                                    |                 |
     *                           IPHostPrimitiveToken   IP6HostPrimitiveToken
     *                           
     *              and we replace all those 3 non connected token by this AndCombinerToken which contains all 3 tokens but in a tree format. 
     *              The old AndCombinerToken by the way was a lonely token which had his two children set to NULL.
     *              The new AndCombinerToken, contains both PrimitiveTokens as children.
     *             
     *              Remark that the EndOfLineToken is nowhere to be found anymore in the final token structure (which contains only a single AndCombinerToken
     *              on top of the stack, and two separate children IPHostPrimitiveToken and IP6HostPrimitiveToken as the 2 childeren).
     *             
     *                                 
     * In the case that LeftParenthesisToken and RightParenthesisTokens would be in the list. We would evaluate what was between those 2 tokens first, and replace that by
     * a single combined token which contains all other tokens in it as well. The reason we allow parentheses is because we can change the way in which the tree is formed, by
     * evaluating certain parts first over other parts.
     *
     * @param token The token that must be pushed on the parse stack now
     * @param errh An error handler which keeps track of possible errors encountered
     * @return When a grammatical error occurs return -1. When everything succeeds return 0.
     * @pre The first Token passed to this function must not be of type CombinerToken. Not adhering this rule leads to unspecified behavior.
     */
    int ParseStack::push_on_stack_and_possibly_evaluate(Token *token, ErrorHandler *errh) {
        if (dynamic_cast<RightParenthesisToken*>(token)) {  // We need to evaluate this time because we encountered a ')' token.
            return evaluate_parenthesis_version(errh);
        } else if (dynamic_cast<EndOfLineToken*>(token)) {  // We need to evaluate this time because we encountered an EndOfLineToken
            return evaluate_end_of_line_version(errh);
        } else {        // We do not need to evaluate this time so we push the token on the top of the stack, to (normally if nothing goes wrong) get later evaluated.
            stack.push_back(token);
        }
        return 0;       // We did not encounter errors after this push (and possible evaluation, depending on which branch we took above)
    }
    
    /*
     * @brief Gives the AST back if nothing went wrong. Does one last evaluation to indicate that the end of line was found.
     */
    int ParseStack::get_AST(AST &ast, ErrorHandler* errh) {
        if (stack.size() > 1) {
            errh->error("We encountered a bug. The ParseStack should have had only 1 member"); return -1;
        }
        ast.root = stack[0];
        return 0;
    }
    
    /*
     * @brief evaluates all the tokens that are on the stack to 1 token
     * @return returns -1 on an error, or 0 when everything went fine
     */
    int ParseStack::evaluate_end_of_line_version(ErrorHandler *errh) {
        if (stack.size() == 1) {
            return 0;
        }
        
        return evaluate_common_part(0, stack.size() - 1, false, errh);  // stack.size() - 1 because the last token is the EndOfLineToken, which
}                                                                       // is not interesting in the evaluation process
    
    /*
     * @brief evaluates what is between two parentheses and reduces the 2 parentheses and everything what was in between to one token
     * @return returns -1 on an error, or 0 when everything went fine
     */
    int ParseStack::evaluate_parenthesis_version(ErrorHandler *errh) {
        // first find the corresponding left parenthesis
        int position_of_last_left_parenthesis_token = -1;
        for (int i = stack.size() -1; i >= 0; i--) {
            if (dynamic_cast<LeftParenthesisToken*>(stack[i])) {
                position_of_last_left_parenthesis_token = i; break;
            }
        }
        if (position_of_last_left_parenthesis_token == -1) {
            errh->error("No left parenthesis found for an encountered right parenthesis"); return -1;
        }
        
        if (stack.size() - 1 == position_of_last_left_parenthesis_token) {  // we got nothing between the left and right parenthesis, these parentheses can be ingnored
                                                                            // we will pop away the left parenthesis token which was still on the stack
            delete stack[stack.size()-1];       // free the memory of the element to be removed
            stack.pop_back();                   // ... and remove from the list with pop_back()
            
            return 0;                                                       
        }
        
        if (stack.size() - 2 == position_of_last_left_parenthesis_token) {  // only one Token was between the parentheses, this must be a PrimitiveToken or we have an error
            if (PrimitiveToken* primitive_token = dynamic_cast<PrimitiveToken*>(stack[stack.size() -1])) {  // if it is a PrimitiveToken, remove the parentheses
                for (int i = 0; i < 2; i++) {       // remove the old 2 tokens (the left parenthesis token and this primitive token)
       //   Only remove if it is a parenthesis , this is the last term. , the first one must be kept
       //             delete stack[stack.size()-1];       // free the memory of the element to be removed
                    stack.pop_back();                   // ... and remove from the list with pop_back()
                }
                stack.push_back(primitive_token);   // and replace it by a single primitive token not between '(' and ')'
                return 0;
            } else {
                errh->error("Single non primitive token between parentheses found. This is not allowed."); return -1;
            }
        }
        
        return evaluate_common_part(position_of_last_left_parenthesis_token + 1, stack.size() - 1, true, errh);
    }
    
    /*
     * @brief Both the evaluation between two parentheses and the evaluation of the entire stack have some common functionality. This functionality is saved here.
     * @param first_token_location the location of the first token to be evaluated on our stack
     * @param last_token_location the location of the last token to be evaluated on our stack
     * @param is_called_by_parenthesis_version Is this called by the function evaluate_parenthesis_version (then this variable must be true) or by evaluate_end_of_line_version (then this variable must be false)
     * @return returns - on an error, or  when everything went fine
     */
    int ParseStack::evaluate_common_part(int first_token_location, int last_token_location, bool is_called_by_parenthesis_version, ErrorHandler *errh) {
        // example: ... (host 10.2.2.7 or host 2001:cdba:0000:0000:0000:0000:3257:9652 or src port 2000) ...
        //                ^            ^                             ^                 ^  ^
        //                |            |                             |                 |  |
        //       start_of_evaluation  start_of_evaluation + 1  start_of_evaluation + 2 |  ------------------- start_of_evaluation + 4
        //                                                                             |
        //                                                                             |
        //                                                                             ------- start_of_evaluation + 3
        //              
        //
        // In our first run we substitute 'host 10.2.2.7 or host 2001:cdba:0000:0000:0000:0000:3257:9652' by   
        //
        //                  or
        //                   |
        //          -----------------
        //          |               |
        //   host 10.2.7.7  host 2001:cdba:0000:0000:0000:0000:3257:9652
        //
        // And save this in a new node of type OrCombinerToken 
        //
        // Then we move from start_of_evaluation to start_of_evaluation + 2.  (i = i + 2 in the code below)
        //
        // In our second run we substitute 
        //
        //  '               or                                                          or src port 2000'
        //                   |
        //          -----------------                                         
        //          |               |
        //   host 10.2.7.7  host 2001:cdba:0000:0000:0000:0000:3257:9652
        //
        //
        // by
        //
        //                                                                    or
        //                                                                    |
        //                                                  ---------------------------------
        //                                                  |                               |
        //                                                  or                          src port 2000
        //                                                  |
        //                                    -------------------------------
        //                                    |                             |   
        //                          host 10.2.7.7               host 2001:cdba:0000:0000:0000:0000:3257:9652
        //
        //
        
        // In case we are evaluating something between parentheses, the left parenthesis token could have been preced by a not. As in 
        // "not (host 10.2.7.7 or host 2001:cdba:0000:0000:0000:0000:3257:9652 or src port 2000)"
        // If that happens we need to negate the resulting ASTNode that we would normally push on the top of the stack, if the parentheses were not
        // preceded by a not.
        //
        // An example,
        // "host 10.5.6.2 or host 10.2.3.5" gives
        //
        //                or
        //                |
        //      --------------------
        //      |                  |
        // host 10.5.6.2    host 10.2.3.5
        //
        // And the negated form
        // "not (host 10.5.6.2 or host 10.2.3.5)" must become
        //
        //                and
        //                 |
        //     -------------------------
        //     |                       |
        // not host 10.5.6.2   not host 10.2.3.5
        //
        // This is principle for negating the trees is based on the mathematical rules:
        // not (a or b) => not a and not b
        // not (a and b) => not a or not b
        //
        // And can be done by calling the int ASTNode* create_negated_node(ASTNode *original_node); function. This node will create the negated alternative 
        // of the node and will free up the space the original node took.
        
        bool negate_at_the_end = false;
        if (is_called_by_parenthesis_version) {
            LeftParenthesisToken *left_parenthesis_token = dynamic_cast<LeftParenthesisToken*>(stack[first_token_location-1]);
            negate_at_the_end = left_parenthesis_token->is_preceded_by_not_keyword;
        }
        
        if (!((last_token_location - first_token_location + 1) % 2)) {
            errh->error("The number of tokens that need to be evaluated is even, this must be an odd number of tokens"); return -1;
        }
        Token* temp_tree = 0;   // this is the tree we are going to build
        if (CombinerToken *combiner_token = dynamic_cast<CombinerToken*>(stack[first_token_location])) {
            if (combiner_token->left_child == NULL || combiner_token->right_child == NULL) {
                if (is_called_by_parenthesis_version) {
                    errh->error("The first token between parentheses is a CombinerToken* without children, we expected one with children or a PrimitiveToken* instead"); return -1;
                } else {
                    errh->error("The first token of our filter expression a CombinerToken* without children, we expected one with children or a PrimitiveToken* instead"); return -1;
                }
            }
        }
        if (!dynamic_cast<CombinerToken*>(stack[first_token_location+1])) {
            if (is_called_by_parenthesis_version) {
                errh->error("The second token between parentheses is not a CombinerToken*, we expected a CombinerToken*"); return -1;
            } else {
                errh->error("The second token between parentheses is not a CombinerToken*, we expected a CombinerToken*"); return -1;
            }
        }
        if (CombinerToken *combiner_token = dynamic_cast<CombinerToken*>(stack[first_token_location+2])) {
            if (combiner_token->left_child == NULL || combiner_token->right_child == NULL) {
                if (is_called_by_parenthesis_version) {
                    errh->error("The third token between parentheses is an CombinerToken* without children, we expected one with children or a PrimitiveToken* instead"); return -1;
                } else {
                    errh->error("The third token of our filter expression is not a CombinerToken* without children, we expected one with children or a PrimitiveToken* instead"); return -1;
                }
            }
        }
        if (dynamic_cast<AndCombinerToken*>(stack[first_token_location+1])) {
            temp_tree = new AndCombinerToken();
            temp_tree->left_child = stack[first_token_location];
            temp_tree->right_child = stack[first_token_location+2];
        } else { // it is an OrCombinerToken*
            temp_tree = new OrCombinerToken();
            temp_tree->left_child = stack[first_token_location];
            temp_tree->right_child = stack[first_token_location+2];        
        }
        
        // Now continue if the list is longer than 3 items
        for (int i = first_token_location + 2; i < last_token_location; i = i + 2) {
            if (!dynamic_cast<CombinerToken*>(stack[i+1])) {
                if (is_called_by_parenthesis_version) {
                    errh->error("We expected a CombinerToken* at position %i in the list", (i - first_token_location) + 2); return -1;
                } else {
                    errh->error("We expected a CombinerToken* at position %i in the filter expression", i+1); return -1;
                }
            }
            if (CombinerToken *combiner_token = dynamic_cast<CombinerToken*>(stack[i+2])) {
                if (combiner_token->left_child == NULL || combiner_token->right_child == NULL) {
                    if (is_called_by_parenthesis_version) {
                        errh->error("We got a CombinerToken* without children at position %i in the list", (i - first_token_location) + 3); return -1;
                    } else {
                        errh->error("We got a CombinerToken* without children at position %i in the filter expression", i+2); return -1;
                    }
                }
            }
            if (dynamic_cast<AndCombinerToken*>(stack[i+1])) {
                AndCombinerToken* and_combiner_token = new AndCombinerToken();
                and_combiner_token->left_child = temp_tree;
                and_combiner_token->right_child = stack[i+2];
                temp_tree = and_combiner_token;
            } else {    // it is an OrCombinerToken*
                OrCombinerToken* or_combiner_token = new OrCombinerToken();
                or_combiner_token->left_child = temp_tree;
                or_combiner_token->right_child = stack[i+2];
                temp_tree = or_combiner_token;
            }
        }
        
        // Now pop the old tokens of the stack and replace them by the the temporary tree (temp_tree) which contains the previous tokens met in Tree form.
        if (is_called_by_parenthesis_version) {  // If it is called by the parenthesis version also remove the parenthesis at the start and at the end
            for (int i = first_token_location-1; i <= last_token_location; i++) {
            // Only delete when it is a token that was not added to an other tree node (e.g. a left parenthesistoken or a rightparenthesistoken)
            
            //    delete stack[stack.size()-1];       // free the memory of the element to be removed
                stack.pop_back();                   // ... and remove from the list with pop_back()  
            }
        } else {
            for (int i = first_token_location; i <= last_token_location; i++) {
              //  delete stack[stack.size()-1];       // free the memory of the element to be removed
                stack.pop_back();                   // ... and remove from the list with pop_back()
            }
        }
        
        // Now, negate the temporary tree (temp_tree) and then push on the stack if a our evaluation procedure was preceded by a not keyword,
        // Or just push it push it on the stack if our evaluation was not preceded by a not keyword.
        if (negate_at_the_end) {
            Token *negated_tree = create_negated_node(temp_tree);
            delete temp_tree;   // This delete deletes the whole tree (and not this node alone), because the destructor deletes the children of the tree as well.
            stack.push_back(negated_tree);
        } else {
            stack.push_back(temp_tree);
        }
        
        return 0;
    }
};

CLICK_ENDDECLS
ELEMENT_PROVIDES(IP6ClassifierParseStack)
